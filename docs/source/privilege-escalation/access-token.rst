

Манипуляции с токенами доступа
======================================

Злоумышленники могут изменять маркеры доступа, чтобы работать под другим контекстом безопасности пользователя или системы для выполнения действий и обхода контроля доступа. Windows использует маркеры доступа для определения права собственности на запущенный процесс. Пользователь может манипулировать маркерами доступа, чтобы запущенный процесс выглядел так, будто он является дочерним процессом другого процесса или принадлежит не тому пользователю, который запустил процесс. Когда это происходит, процесс также принимает контекст безопасности, связанный с новым маркером.

Противник может использовать встроенные функции Windows API для копирования маркеров доступа из существующих процессов; это называется кражей маркера. Затем эти маркеры могут быть применены к существующему процессу или использованы для порождения нового процесса. Чтобы украсть токен, противник должен уже находиться в контексте привилегированного пользователя. Однако противники обычно используют кражу маркера, чтобы поднять свой контекст безопасности с уровня администратора до уровня SYSTEM. Затем противник может использовать токен для аутентификации в удаленной системе в качестве учетной записи для этого токена, если у этой учетной записи есть соответствующие разрешения в удаленной системе[1].

Любой обычный пользователь может использовать команду runas и функции Windows API для создания маркеров имперсонации; для этого не требуется доступ к учетной записи администратора. Существуют и другие механизмы, например поля Active Directory, которые можно использовать для изменения маркеров доступа.



Подделка/кража токенов
-------------------------------------------------

Злоумышленники могут дублировать и выдавать себя за существующий токен другого пользователя, чтобы повысить привилегии и обойти контроль доступа. Например, злоумышленник может продублировать существующий токен с помощью DuplicateToken или DuplicateTokenEx. Затем этот токен можно использовать с помощью ImpersonateLoggedOnUser, чтобы позволить вызывающему потоку выдавать себя за контекст безопасности вошедшего в систему пользователя, или с помощью SetThreadToken, чтобы присвоить токен, выданный за токен, потоку.

Противник может выполнить имперсонацию/кражу токена, когда у него есть конкретный существующий процесс, которому он хочет присвоить дублированный токен. Например, это может быть полезно, когда целевой пользователь имеет несетевую сессию входа в систему.

Если злоумышленник хочет использовать дублированный токен для создания нового процесса, а не прикрепления к существующему, он может дополнительно создать процесс с токеном с помощью CreateProcessWithTokenW или CreateProcessAsUserW. Кража/персонификация токена также отличается от Make и Impersonate Token тем, что относится к дублированию существующего токена, а не к созданию нового.



Создание процесса с помощью токена
-------------------------------------------------

Злоумышленники могут создать новый процесс с существующим токеном, чтобы повысить привилегии и обойти контроль доступа. Процессы могут быть созданы с токеном и результирующим контекстом безопасности другого пользователя с помощью таких функций, как CreateProcessWithTokenW и runas[1].

Для создания процессов с маркером, не связанным с текущим пользователем, могут потребоваться учетные данные целевого пользователя, специальные привилегии для выдачи себя за него или доступ к используемому маркеру. Например, токен может быть продублирован с помощью Token Impersonation/Theft или создан с помощью Make and Impersonate Token перед использованием для создания процесса.

Хотя эта техника отличается от Token Impersonation/Theft, они могут использоваться совместно, когда токен дублируется, а затем используется для создания нового процесса.



Создание и имперсонация токена
-------------------------------------------------

Злоумышленники могут создавать новые токены и выдавать себя за пользователей, чтобы повысить привилегии и обойти контроль доступа. Например, если у злоумышленника есть имя пользователя и пароль, но пользователь не вошел в систему, он может создать для него сеанс входа в систему с помощью функции LogonUser. Функция вернет копию маркера доступа новой сессии, и злоумышленник может использовать SetThreadToken, чтобы присвоить маркер потоку.

Это поведение отличается от Token Impersonation/Theft тем, что здесь речь идет о создании нового токена пользователя, а не о краже или дублировании существующего.


Подмена родительского PID
-------------------------------------------------

Злоумышленники могут подменить идентификатор родительского процесса нового процесса, чтобы обойти средства защиты от мониторинга процессов или повысить привилегии. Новые процессы обычно порождаются непосредственно из родительского, или вызывающего, процесса, если это не указано явно. Одним из способов явного назначения PPID нового процесса является вызов API CreateProcess, который поддерживает параметр, определяющий используемый PPID.[1] Эта функциональность используется такими функциями Windows, как User Account Control, для правильной установки PPID после того, как запрашиваемый процесс с повышенными привилегиями порождается SYSTEM, а не контекстом текущего пользователя.[2]

Злоумышленники могут злоупотреблять этими механизмами, чтобы обойти средства защиты, например, блокирующие процессы, порождаемые непосредственно из документов Office, и анализ, направленный на необычные/потенциально вредоносные отношения между родительскими и дочерними процессами, например, подмена PPID PowerShell/Rundll32 на explorer.exe, а не на документ Office, доставленный в составе вложения для копьеметания.[3] Эта подмена может быть выполнена с помощью Visual Basic внутри вредоносного документа Office или любого кода, который может выполнять Native API.[4][3]

Явное назначение PPID может также обеспечить повышенные привилегии при наличии соответствующих прав доступа к родительскому процессу. Например, злоумышленник в контексте привилегированного пользователя может породить новый процесс и назначить его родителем процесс, запущенный от имени SYSTEM, в результате чего новый процесс получит повышенные права доступа через унаследованный маркер доступа[5].